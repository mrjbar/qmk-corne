#include QMK_KEYBOARD_H


/* THIS FILE WAS GENERATED!
 *
 * This file was generated by qmk json2c. You may or may not want to
 * edit it directly.
 */

#define KC_SELL RALT(RCTL(KC_S))
#define KC_BID LALT(LCTL(KC_B))
#define KC_CANCEL LALT(LCTL(KC_C))
#define SSHOT_REG LCTL(LGUI(LSFT(KC_4)))
#define SSHOT_FILE RGUI(RSFT(KC_4))
#define SPACE_1 LCTL(KC_1)
#define SPACE_2 LCTL(KC_2)
#define SPACE_3 LCTL(KC_3)

enum custom_keycodes {
  RGB_SLD = SAFE_RANGE,
  ITERM,
  FIREFOX,
  SLACK,
  OUTLOOK,
  LENS,
  DIR_GO,
  FIND_FILE,
  GREP_FILE,
  BUFFERED_FILE,
  MONTHLY,
  WEEKLY,
  DAILY,
  HOURLY,
  MIN_20,
  MIN_5,
  TMUX_RENAME,
  TMUX_MANAGE,
  UPTIME,
  DMESG,
  VMSTAT,
  MPSTAT,
  PIDSTAT,
  IOSTAT,
  FREE,
  SAR_NET,
  SAR_TCP,
  TOP,
  OS_CLTR_HLTH,
  OS_CLTR_IDX,
  OS_CLTR_ALLOC,
  OS_CLTR_SET,
  OS_CAT_RCVRY,
  OS_CAT_ALLOC,
  OS_REROUTE,
  OS_CAT_NODE,
  //CURL_PERF,
  //PERF_TOP,
  //PERF_RECORD_SYS,
  //PERF_RECORD_PID,
  //PERF_RECORD_CGROUP,
  //PERF_REPORT,
  TCPDUMP_DNS,
  SHOW_CERT,
  SHOW_REMOTE_CERT,
  //EXTRACT_CERT,
  //EXTRACT_ALL_CERT,
  //OPENSSL_PERF,
};

enum tap_dance_codes {
  COLON_SEMI,
  //TD_OCI_OPS,
  TD_SPACE_TAB,
};

enum layers{
  BASE,
  SYM,
  NUM,
  NAV,
  OPS,
  NINJA,
};

enum combos {
    RT_F1,
    CAPS_COMBO,
    TS_SHIFT,
    COMBO_LENGTH
};

//uint16_t COMBO_LEN = COMBO_LENGTH;

const uint16_t PROGMEM rt_combo[] = {KC_R, KC_T, COMBO_END};
const uint16_t PROGMEM caps_combo[] = {KC_Y, KC_U, COMBO_END};
const uint16_t PROGMEM tilde_slash_combo[] = {KC_TILD, KC_SLSH, COMBO_END};

combo_t key_combos[COMBO_COUNT] = {
[RT_F1] = COMBO(rt_combo, KC_F1),
[TS_SHIFT] = COMBO(tilde_slash_combo, KC_RSFT),
[CAPS_COMBO] = COMBO_ACTION(caps_combo),
};

void process_combo_event(uint16_t combo_index, bool pressed) {
  switch(combo_index) {
    case CAPS_COMBO:
      if (pressed) {
        caps_word_on();  // Activate Caps Word!
      }
      break;
    // Other combos...
  }
}

const char opensearch_domain [] = "curl -XGET \"https://opensearch-master:9200/";

const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
	[BASE] = LAYOUT_split_3x6_3(
                KC_F1, KC_Q, KC_W, KC_E, KC_R, KC_T,                                        KC_Y, KC_U, KC_I, KC_O, KC_P, TO(5), 
                CAPSWRD, MT(MOD_LGUI,KC_A), OPT_T(KC_S), LCTL_T(KC_D), LSFT_T(KC_F), KC_G,  KC_H, RSFT_T(KC_J), RCTL_T(KC_K), OPT_T(KC_L), KC_COLN, KC_QUOT, 
                OSM(MOD_LSFT), LT(0,KC_Z), LT(0,KC_X), LT(0,KC_C), LT(0,KC_V), KC_B,        KC_N, KC_M, KC_COMM, KC_DOT, KC_SLSH, OSL(4), 
                KC_TAB, LT(1,KC_SPC), LT(3, KC_ESC),                                        LT(2, KC_BSPC), LT(1, KC_ENT), KC_DEL),
	[SYM] = LAYOUT_split_3x6_3(
                KC_NO, KC_EQL, KC_AMPR, KC_ASTR, KC_LPRN, KC_PIPE,                          KC_NO, KC_LCBR, KC_RCBR, KC_NO, KC_NO, KC_NO,
                KC_NO, KC_TILD, KC_DLR, KC_PERC, KC_CIRC, KC_UNDS,                          KC_NO, KC_LPRN, KC_RPRN, KC_NO, KC_NO, KC_NO,
                KC_NO, KC_GRV, KC_EXLM, KC_AT, KC_HASH, KC_BSLS,                            KC_NO, KC_LBRC, KC_RBRC, KC_NO, KC_NO, KC_NO,
                KC_NO, KC_NO, DIR_GO,                                                       KC_NO, KC_NO, KC_NO),
	[NUM] = LAYOUT_split_3x6_3(
                KC_NO, KC_NO, KC_7, KC_8, KC_9, KC_EQL,                                     KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO,
                KC_NO, KC_NO, KC_4, KC_5, KC_6, KC_MINUS,                                   KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO,
                KC_NO, KC_NO, KC_1, KC_2, KC_3, KC_PPLS,                                    KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO,
                KC_NO, KC_NO, KC_0,                                                         KC_NO, KC_NO, KC_NO),
	[NAV] = LAYOUT_split_3x6_3(
                QK_BOOT, KC_NO, SPACE_1, SPACE_2, SPACE_3, SSHOT_REG,                       TMUX_MANAGE, KC_PGDN, KC_PGUP, KC_NO, KC_NO, KC_VOLU,
                LENS, OUTLOOK, SLACK, ITERM, FIREFOX, SSHOT_FILE,                           KC_LEFT, KC_DOWN, KC_UP, KC_RGHT, KC_NO, KC_VOLD, 
                KC_NO, KC_NO, BUFFERED_FILE, FIND_FILE, GREP_FILE, KC_NO,                   TMUX_RENAME, KC_END, KC_HOME, KC_NO, KC_NO, KC_MUTE, 
                KC_NO, KC_NO, KC_TRNS,                                                      KC_NO, KC_NO, KC_NO),
	[OPS] = LAYOUT_split_3x6_3(
                SHOW_CERT, KC_NO, FREE, SAR_NET, SAR_TCP, KC_NO,                            OS_CLTR_HLTH, OS_CLTR_SET, OS_REROUTE, KC_NO, KC_NO, KC_NO,
                KC_NO, KC_NO, MPSTAT, PIDSTAT, IOSTAT, KC_NO,                               OS_CLTR_IDX, OS_CLTR_ALLOC, OS_CAT_RCVRY, KC_NO, KC_NO, KC_NO,
                KC_NO, TCPDUMP_DNS, UPTIME, DMESG, VMSTAT, KC_NO,                           OS_CAT_ALLOC, OS_CAT_NODE, KC_NO, KC_NO, KC_NO, KC_NO,
                KC_NO, KC_NO, KC_NO,                                                        KC_NO, KC_NO, KC_NO),
	[NINJA] = LAYOUT_split_3x6_3(
                KC_ESC, KC_F8, LALT(LCTL(KC_G)), KC_F6, KC_F4, KC_F7,                       KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, TO(0),
                KC_NO, KC_NO, MONTHLY, WEEKLY, DAILY, KC_NO,                                KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO,
                KC_NO, KC_NO, HOURLY, MIN_20, MIN_5, KC_NO,                                 KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO,
                KC_NO, KC_CANCEL, KC_BID,                                                   KC_SELL, KC_CANCEL, KC_NO),
};

bool process_record_user(uint16_t keycode, keyrecord_t *record) {
  switch (keycode) {
    case DIR_GO:
    if (record->event.pressed) {
      SEND_STRING("~/");

    }
    break;
    case FIND_FILE:
    if (record->event.pressed) {
      SEND_STRING(SS_TAP(X_SPACE) SS_TAP(X_F) SS_TAP(X_F));

    }
    break;
    case GREP_FILE:
    if (record->event.pressed) {
      SEND_STRING(SS_TAP(X_SPACE) SS_TAP(X_F) SS_TAP(X_G));

    }
    break;
    case BUFFERED_FILE:
    if (record->event.pressed) {
      SEND_STRING(SS_TAP(X_SPACE) SS_TAP(X_F) SS_TAP(X_B));

    }
    break;
    case TMUX_RENAME:
    if (record->event.pressed) {
      SEND_STRING(SS_LCTL(SS_TAP(X_B)) SS_LSFT(SS_TAP(X_4)));

    }
    break;
    case TMUX_MANAGE:
    if (record->event.pressed) {
      SEND_STRING(SS_RCTL(SS_TAP(X_B)) SS_TAP(X_S));

    }
    break;
    case MONTHLY:
    if (record->event.pressed) {
      SEND_STRING(SS_TAP(X_1) SS_TAP(X_M) SS_TAP(X_O)  SS_TAP(X_ENTER));

    }
    break;
    case WEEKLY:
    if (record->event.pressed) {
      SEND_STRING(SS_TAP(X_1) SS_TAP(X_W)  SS_TAP(X_ENTER));

    }
    break;
    case DAILY:
    if (record->event.pressed) {
      SEND_STRING(SS_TAP(X_1) SS_TAP(X_D)  SS_TAP(X_ENTER));

    }
    break;
    case HOURLY:
    if (record->event.pressed) {
      SEND_STRING(SS_TAP(X_6) SS_TAP(X_0) SS_TAP(X_M)  SS_TAP(X_ENTER));

    }
    break;
    case MIN_20:
    if (record->event.pressed) {
      SEND_STRING(SS_TAP(X_2) SS_TAP(X_0) SS_TAP(X_M)  SS_TAP(X_ENTER));

    }
    break;
    case MIN_5:
    if (record->event.pressed) {
      SEND_STRING(SS_TAP(X_5) SS_TAP(X_M)  SS_TAP(X_ENTER));

    }
    break;
    case UPTIME:
    if (record->event.pressed) {
      SEND_STRING("uptime");

    }
    break;
    case DMESG:
    if (record->event.pressed) {
      SEND_STRING("dmesg -T | tail");

    }
    break;
    case VMSTAT:
    if (record->event.pressed) {
      SEND_STRING("vmstat -SM 1");

    }
    break;
    case MPSTAT:
    if (record->event.pressed) {
      SEND_STRING("mpstat -P ALL 1");

    }
    break;
    case PIDSTAT:
    if (record->event.pressed) {
      SEND_STRING("pidstat 1");

    }
    break;
    case IOSTAT:
    if (record->event.pressed) {
      SEND_STRING("iostat -sxz 1");

    }
    break;
    case FREE:
    if (record->event.pressed) {
      SEND_STRING("free -m");

    }
    break;
    case SAR_NET:
    if (record->event.pressed) {
      SEND_STRING("sar -n DEV 1");

    }
    break;
    case SAR_TCP:
    if (record->event.pressed) {
      SEND_STRING("sar -n TCP,ETCP 1");

    }
    break;
    case TOP:
    if (record->event.pressed) {
      SEND_STRING("top");

    }
    break;
    case OS_CLTR_HLTH:
    if (record->event.pressed) {
      send_string(opensearch_domain);
      SEND_STRING("_cluster/health?pretty\" --insecure");
    }
    break;
    case OS_CLTR_IDX:
    if (record->event.pressed) {
      send_string(opensearch_domain);
      SEND_STRING("_cat/indices?pretty\" --insecure");
    }
    break;
    case OS_CLTR_ALLOC:
    if (record->event.pressed) {
      send_string(opensearch_domain);
      SEND_STRING("_cluster/allocation/explain?pretty\" --insecure");
    }
    break;
    case OS_CLTR_SET:
    if (record->event.pressed) {
      send_string(opensearch_domain);
      SEND_STRING("_cluster/settings?include_defaults=true&pretty\" --insecure");
    }
    break;
    case OS_CAT_RCVRY:
    if (record->event.pressed) {
      send_string(opensearch_domain);
      SEND_STRING("_cluster/reroute?retry_failed=true\" --insecure -u admin:");
    }
    break;
    case OS_CAT_NODE:
    if (record->event.pressed) {
      send_string(opensearch_domain);
      SEND_STRING("_cat/nodes?v=true&h=n,id,u,l,cpu,hc,rc,rm,dup,sqti\" --insecure");
    }
    break;
    /**
    case CURL_PERF:
    if (record->event.pressed) {
      SEND_STRING("curl -w \"dns:%{time_namelookup}\\ntcp:%{time_connect}\\ntls:%{time_appconnect}\\n%{time_pretransfer}\\n%{time_starttransfer}\\n%{time_total}\\n%{url_effective}\\n\" -o /dev/null ");
    }
    break;
    case PERF_TOP:
    if (record->event.pressed) {
      SEND_STRING("sudo perf top -F 49");
    }
    break;
    case PERF_RECORD_SYS:
    if (record->event.pressed) {
      SEND_STRING("sudo perf record -F 99 -g -- sleep 10");
    }
    break;
    case PERF_RECORD_PID:
    if (record->event.pressed) {
      SEND_STRING("sudo perf record -F 99 -p ");
    }
    break;
    case PERF_RECORD_CGROUP:
    if (record->event.pressed) {
      SEND_STRING("sudo perf record -F 99 -e cpu-clock -a -- sleep 10 --cgroup=docker/1dc...");
    }
    break;
    case PERF_REPORT:
    if (record->event.pressed) {
      SEND_STRING("sudo perf report");
    }
    break;
    **/
    case TCPDUMP_DNS:
    if (record->event.pressed) {
      SEND_STRING("sudo tcpdump -vvAs0 port 53");
    }
    break;
    case SHOW_REMOTE_CERT:
    if (record->event.pressed) {
      SEND_STRING("echo \"\" | openssl s_client -connect $endpoint:443  2>/dev/null | openssl x509 -noout -issuer -subject -dates");
    }
    break;
    case SHOW_CERT:
    if (record->event.pressed) {
      SEND_STRING("openssl x509 -noout -issuer -subject -dates -in ");
    }
    break;
    /**
    case EXTRACT_CERT:
    if (record->event.pressed) {
      SEND_STRING("echo | openssl s_client -connect $endpoint:443 2>&1 | sed -n -e '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p'");
    }
    break;
    case EXTRACT_ALL_CERT:
    if (record->event.pressed) {
      SEND_STRING("echo | openssl s_client -showcerts -connect $endpoint:443 2>&1 | sed -n -e '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p'");
    }
    break;
    case OPENSSL_PERF:
    if (record->event.pressed) {
      SEND_STRING("openssl s_time -connect example.com:443 -new");
    }
    break;
    **/
    case ITERM:
    if (record->event.pressed) {
      SEND_STRING(SS_LGUI(SS_TAP(X_SPACE)) SS_DELAY(100) "iterm.app" SS_DELAY(100) SS_TAP(X_ENTER));
    }
    break;
    case FIREFOX:
    if (record->event.pressed) {
      SEND_STRING(SS_LGUI(SS_TAP(X_SPACE)) SS_DELAY(100) "firefox.app" SS_DELAY(100) SS_TAP(X_ENTER));
    }
    break;
    case SLACK:
    if (record->event.pressed) {
      SEND_STRING(SS_LGUI(SS_TAP(X_SPACE)) SS_DELAY(100) "slack.app" SS_DELAY(100) SS_TAP(X_ENTER));
    }
    break;
    case OUTLOOK:
    if (record->event.pressed) {
      SEND_STRING(SS_LGUI(SS_TAP(X_SPACE)) SS_DELAY(100) "outlook.app" SS_DELAY(100) SS_TAP(X_ENTER));
    }
    break;
    case LENS:
    if (record->event.pressed) {
      SEND_STRING(SS_LGUI(SS_TAP(X_SPACE)) SS_DELAY(100) "lens.app" SS_DELAY(100) SS_TAP(X_ENTER));
    }
    break;
    case LT(0,KC_Z):
    if (!record->tap.count && record->event.pressed) {
      tap_code16(LGUI(KC_Z)); // Intercept hold function to send Command-X
    return false;
    }
    break;
    case LT(0,KC_X):
    if (!record->tap.count && record->event.pressed) {
      tap_code16(LGUI(KC_X)); // Intercept hold function to send Command-X
    return false;
    }
    break;
    case LT(0,KC_C):
    if (!record->tap.count && record->event.pressed) {
      tap_code16(LGUI(KC_C)); // Intercept hold function to send Command-X
    return false;
    }
    break;
    case LT(0,KC_V):
    if (!record->tap.count && record->event.pressed) {
      tap_code16(LGUI(KC_V)); // Intercept hold function to send Command-X
    return false;
    }
    break;
  }
  return true;
}


typedef struct {
    bool is_press_action;
    uint8_t step;
} tap;

enum {
    SINGLE_TAP = 1,
    SINGLE_HOLD,
    DOUBLE_TAP,
    DOUBLE_HOLD,
    DOUBLE_SINGLE_TAP,
    MORE_TAPS
};

static tap dance_state[11];

uint8_t dance_step(qk_tap_dance_state_t *state);

uint8_t dance_step(qk_tap_dance_state_t *state) {
    if (state->count == 1) {
        if (state->interrupted || !state->pressed) return SINGLE_TAP;
        else return SINGLE_HOLD;
    } else if (state->count == 2) {
        if (state->interrupted) return DOUBLE_SINGLE_TAP;
        else if (state->pressed) return DOUBLE_HOLD;
        else return DOUBLE_TAP;
    }
    return MORE_TAPS;
}



void on_dance_6(qk_tap_dance_state_t *state, void *user_data);
void dance_6_finished(qk_tap_dance_state_t *state, void *user_data);
void dance_6_reset(qk_tap_dance_state_t *state, void *user_data);

void on_dance_6(qk_tap_dance_state_t *state, void *user_data) {
    if(state->count == 3) {
        tap_code16(KC_SPC);
        tap_code16(KC_SPC);
        tap_code16(KC_SPC);
    }
    if(state->count > 3) {
        tap_code16(KC_SPC);
    }
}

void dance_6_finished(qk_tap_dance_state_t *state, void *user_data) {
    dance_state[6].step = dance_step(state);
    switch (dance_state[6].step) {
        case SINGLE_TAP: register_code16(KC_SPC); break;
        case SINGLE_HOLD: register_code16(KC_SPC); break;
        case DOUBLE_TAP: register_code16(KC_TAB); register_code16(KC_TAB); break;
        case DOUBLE_SINGLE_TAP: tap_code16(KC_SPC); register_code16(KC_SPC);
    }
}

void dance_6_reset(qk_tap_dance_state_t *state, void *user_data) {
    wait_ms(10);
    switch (dance_state[6].step) {
        case SINGLE_TAP: unregister_code16(KC_SPC); break;
        case SINGLE_HOLD: unregister_code16(KC_SPC); break;
        case DOUBLE_TAP: unregister_code16(KC_TAB); break;
        case DOUBLE_SINGLE_TAP: unregister_code16(KC_SPC); break;
    }
    dance_state[6].step = 0;
}

void on_dance_7(qk_tap_dance_state_t *state, void *user_data);
void dance_7_finished(qk_tap_dance_state_t *state, void *user_data);
void dance_7_reset(qk_tap_dance_state_t *state, void *user_data);

void on_dance_7(qk_tap_dance_state_t *state, void *user_data) {
    if(state->count == 3) {
        tap_code16(RSFT(KC_SCOLON));
        tap_code16(RSFT(KC_SCOLON));
        tap_code16(RSFT(KC_SCOLON));
    }
    if(state->count > 3) {
        tap_code16(RSFT(KC_SCOLON));
    }
}

void dance_7_finished(qk_tap_dance_state_t *state, void *user_data) {
    dance_state[7].step = dance_step(state);
    switch (dance_state[7].step) {
        case SINGLE_TAP: register_code16(RSFT(KC_SCOLON)); break;
        case SINGLE_HOLD: register_code16(KC_SCOLON); break;
        case DOUBLE_TAP: register_code16(RSFT(KC_SCOLON)); register_code16(RSFT(KC_SCOLON)); break;
        case DOUBLE_SINGLE_TAP: tap_code16(RSFT(KC_SCOLON)); register_code16(RSFT(KC_SCOLON));
    }
}

void dance_7_reset(qk_tap_dance_state_t *state, void *user_data) {
    wait_ms(10);
    switch (dance_state[7].step) {
        case SINGLE_TAP: unregister_code16(RSFT(KC_SCOLON)); break;
        case SINGLE_HOLD: unregister_code16(KC_SCOLON); break;
        case DOUBLE_TAP: unregister_code16(RSFT(KC_SCOLON)); break;
        case DOUBLE_SINGLE_TAP: unregister_code16(RSFT(KC_SCOLON)); break;
    }
    dance_state[7].step = 0;
}
/**
void on_dance_layer(qk_tap_dance_state_t *state, void *user_data);
void dance_layer_finished(qk_tap_dance_state_t *state, void *user_data);
void dance_layer_reset(qk_tap_dance_state_t *state, void *user_data);

void on_dance_layer(qk_tap_dance_state_t *state, void *user_data) {}

void dance_layer_finished(qk_tap_dance_state_t *state, void *user_data) {
    dance_state[11].step = dance_step(state);
    switch (dance_state[11].step) {
        case SINGLE_TAP: set_oneshot_layer(OCI, ONESHOT_START); break;
        case DOUBLE_TAP: set_oneshot_layer(OPS, ONESHOT_START); break;
    }
}

void dance_layer_reset(qk_tap_dance_state_t *state, void *user_data) {
    wait_ms(10);
    switch (dance_state[11].step) {
        case SINGLE_TAP: clear_oneshot_layer_state(ONESHOT_PRESSED); break;
        case DOUBLE_TAP: clear_oneshot_layer_state(ONESHOT_PRESSED); break;
    }
    dance_state[11].step = 0;
}
**/
qk_tap_dance_action_t tap_dance_actions[] = {
        [COLON_SEMI] = ACTION_TAP_DANCE_FN_ADVANCED(on_dance_7, dance_7_finished, dance_7_reset),
        //[TD_OCI_OPS] = ACTION_TAP_DANCE_FN_ADVANCED(on_dance_layer, dance_layer_finished, dance_layer_reset),
        [TD_SPACE_TAB] = ACTION_TAP_DANCE_FN_ADVANCED(on_dance_6, dance_6_finished, dance_6_reset)
};

